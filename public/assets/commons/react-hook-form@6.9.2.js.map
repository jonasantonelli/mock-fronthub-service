{"version":3,"sources":["webpack://[name]/webpack/bootstrap","webpack://[name]/external \"react@16.12.0\"","webpack://[name]/./node_modules/react-hook-form/dist/index.esm.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__WEBPACK_EXTERNAL_MODULE__0__","isHTMLElement","HTMLElement","EVENTS","VALIDATION_MODE","INPUT_VALIDATION_RULES","isNullOrUndefined","isArray","Array","isObjectType","isObject","Date","isKey","test","stringToPath","input","result","replace","match","mathNumber","mathQuote","originalString","push","set","path","index","tempPath","length","lastIndex","newValue","objValue","isNaN","transformToNestObject","data","entries","reduce","previous","assign","isUndefined","val","undefined","filterOutFalsy","filter","Boolean","obj","defaultValue","split","removeAllEventListeners","ref","validateWithStateUpdate","removeEventListener","defaultReturn","isValid","getRadioValue","options","option","checked","isRadioInput","element","type","isFileInput","isCheckBoxInput","isMultipleSelect","defaultResult","validResult","getCheckboxValue","values","map","attributes","getFieldValue","fieldsRef","shallowFieldsStateRef","excludeDisabled","field","current","disabled","files","selected","isDetached","nodeType","Node","DOCUMENT_NODE","parentNode","isEmptyObject","keys","isBoolean","unset","updatePath","childObject","slice","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","isSameRef","fieldValue","isString","isPrimitive","getFieldsValues","search","output","startsWith","find","deepMerge","target","source","targetValue","sourceValue","_a","deepEqual","object1","object2","isErrorObject","keys1","keys2","includes","val1","val2","isRegex","RegExp","getValueAndMessage","validationData","isValueMessage","message","isFunction","isMessage","getValidateError","appendErrors","validateAllFieldCriteria","errors","error","types","validateField","async","required","maxLength","minLength","min","max","pattern","validate","fields","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","requiredValue","requiredMessage","exceedMin","maxValue","maxMessage","minValue","minMessage","valueNumber","valueAsNumber","parseFloat","valueDate","valueAsDate","maxLengthValue","minLengthValue","inputLength","toString","patternValue","patternMessage","validateRef","validateError","validationResult","validateFunction","getPath","pathWithIndex","getInnerPath","flat","Infinity","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","forEach","skipValidation","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","getFieldArrayParentName","substring","indexOf","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","modeChecker","isOnSubmit","isRadioOrCheckboxFunction","isWindowUndefined","window","isWeb","document","isProxyEnabled","Proxy","useForm","reValidateMode","resolver","context","defaultValues","shouldFocusError","shouldUnregister","criteriaMode","fieldArrayDefaultValuesRef","watchFieldsRef","Set","useWatchFieldsRef","useWatchRenderFunctionsRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","defaultValuesAtRenderRef","isUnMount","isWatchAllRef","handleChangeRef","resetFieldArrayFunctionRef","contextRef","resolverRef","fieldArrayNamesRef","modeRef","isValidateAllFieldCriteria","formState","setFormState","isDirty","dirtyFields","submitCount","touched","isSubmitting","isSubmitSuccessful","readFormStateRef","formStateRef","observerRef","updateFormState","state","shouldRenderBaseOnError","shouldRender","shouldReRender","validFields","fieldsWithValidation","previousError","isErrorStateChanged","setFieldValue","rawValue","radioRef","selectRef","checkboxRef","isFormDirty","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","previousFormIsValid","isInputsValid","every","trigger","Promise","all","setInternalValues","shouldDirty","shouldValidate","setInternalValue","config","has","setFieldArrayDirtyFields","parentName","isFieldWatched","renderWatchedInputs","found","size","setFieldArrayDefaultValues","payload","shouldSkipValidation","validateResolver","removeFieldEventListener","forceDelete","handleChange","fieldRef","findRemovedFieldAndRemoveListener","removeFieldEventListenerAndRef","watchInternal","fieldNames","watchId","combinedDefaultValues","registerFieldRef","validateOptions","fieldRefAndValidationOptions","isFieldArray","compareRef","currentRef","isEmptyDefaultValue","isEmptyUnmountFields","then","shouldAttachChangeEvent","addEventListener","attachEventListeners","handleSubmit","onValid","onInvalid","e","preventDefault","persist","fieldErrors","fieldError","focus","focusOnErrorField","observer","MutationObserver","observe","childList","subtree","onDomRemove","disconnect","commonProps","setValue","register","refOrValidationOptions","rules","unregister","control","watch","prop","reset","omitResetState","inputRef","closest","resetFieldArray","resetRefs","clearErrors","inputName","setError","shouldFocus","__rest","getOwnPropertySymbols","propertyIsEnumerable","FormContext","displayName","useFormContext","FormProvider","children","props","Provider","generateId","performance","now","Math","random","removeArrayAt","removeAtIndexes","removeAt","moveArrayAt","from","to","splice","swapArrayAt","indexA","indexB","temp","prepend","insert","fillEmptyArray","fill","mapValueToBoolean","filterBooleanArray","appendId","keyName","mapIds","useFieldArray","methods","focusIndexRef","fieldArrayParentName","memoizedDefaultValues","setFields","allFields","getCurrentFieldsValues","appendValueWithKey","setFieldAndValidState","fieldsValues","getIsDirtyState","flagOrFields","_b","resetFields","cleanup","batchStateUpdate","method","args","shouldSet","shouldUpdateValid","argA","argB","argC","argD","pop","shouldRenderUseWatch","watchField","resetFunctions","fieldArrayNames","delete","swap","move","emptyArray","append","dirtyInputs","_","remove","useWatch","idRef","defaultValueRef","updateWatchValue","id","watchFieldsHookRender","watchFieldsHook","Controller","as","render","onFocus","rest","isNotFieldArray","getInitialValue","setInputStateValue","valueRef","onFocusRef","commonTask","event","getInputValue","registerField","onBlur","onChange"],"mappings":"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","file":"react-hook-form@6.9.2.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 98);\n","module.exports = __WEBPACK_EXTERNAL_MODULE__0__;","import { isValidElement, useRef, useState, useCallback, useEffect, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst VALUE = 'value';\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ ref }, shouldAttachChangeEvent, handleChange) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isNullOrUndefined = (value) => value == null;\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar isKey = (value) => !isArray(value) &&\r\n    (/^\\w*$/.test(value) ||\r\n        !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar stringToPath = (input) => {\r\n    const result = [];\r\n    input.replace(/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, (match, mathNumber, mathQuote, originalString) => {\r\n        result.push(mathQuote\r\n            ? originalString.replace(/\\\\(\\\\)?/g, '$1')\r\n            : mathNumber || match);\r\n    });\r\n    return result;\r\n};\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!isKey(key)) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar isUndefined = (val) => val === undefined;\n\nvar filterOutFalsy = (value) => value.filter(Boolean);\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = filterOutFalsy(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || value === ''\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled) {\r\n    const field = fieldsRef.current[name];\r\n    if (field) {\r\n        const { ref: { value, disabled }, ref, } = field;\r\n        if (disabled && excludeDisabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field.options).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field.options).value;\r\n        }\r\n        return value;\r\n    }\r\n    if (shallowFieldsStateRef) {\r\n        return get(shallowFieldsStateRef.current, name);\r\n    }\r\n}\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const path = updatePath.slice(0, -1);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef = undefined;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\r\n    const { ref, ref: { name, type }, } = field;\r\n    const fieldRef = fieldsRef.current[name];\r\n    if (!shouldUnregister) {\r\n        const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        if (!isUndefined(value)) {\r\n            set(shallowFieldsStateRef.current, name, value);\r\n        }\r\n    }\r\n    if (!type) {\r\n        delete fieldsRef.current[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\r\n        const { options } = fieldRef;\r\n        if (isArray(options) && options.length) {\r\n            filterOutFalsy(options).forEach((option, index) => {\r\n                const { ref } = option;\r\n                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\r\n                    removeAllEventListeners(ref, handleChange);\r\n                    unset(options, `[${index}]`);\r\n                }\r\n            });\r\n            if (options && !filterOutFalsy(options).length) {\r\n                delete fieldsRef.current[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fieldsRef.current[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        delete fieldsRef.current[name];\r\n    }\r\n}\n\nfunction setFieldArrayDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setFieldArrayDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                get(defaultValues[index] || {}, key) === values[index][key]\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        !dirtyFields.length &&\r\n            parentNode &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields.length ? dirtyFields : undefined;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            if ((isObject(targetValue) && isObject(sourceValue)) ||\r\n                (isArray(targetValue) && isArray(sourceValue))) {\r\n                target[key] = deepMerge(targetValue, sourceValue);\r\n            }\r\n            else {\r\n                target[key] = sourceValue;\r\n            }\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nvar getFieldsValues = (fieldsRef, shallowFieldsStateRef, excludeDisabled, search) => {\r\n    const output = {};\r\n    for (const name in fieldsRef.current) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : isArray(search) && search.find((data) => name.startsWith(data)))) {\r\n            output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\r\n        }\r\n    }\r\n    return deepMerge(transformToNestObject(Object.assign({}, ((shallowFieldsStateRef || {}).current || {}))), transformToNestObject(output));\r\n};\n\nfunction deepEqual(object1 = [], object2 = [], isErrorObject) {\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        if (!(isErrorObject && ['ref', 'context'].includes(key))) {\r\n            const val1 = object1[key];\r\n            const val2 = object2[key];\r\n            if ((isObject(val1) || isArray(val1)) && (isObject(val2) || isArray(val2))\r\n                ? !deepEqual(val1, val2, isErrorObject)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction isErrorStateChanged({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isValid = isUndefined(error);\r\n    const previousError = get(errors, name);\r\n    return ((isValid && !!previousError) ||\r\n        (!isValid && !deepEqual(previousError, error, true)) ||\r\n        (isValid && get(fieldsWithValidation, name) && !get(validFields, name)));\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nconst isValueMessage = (value) => isObject(value) && !isRegex(value);\r\nvar getValueAndMessage = (validationData) => isValueMessage(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && isValidElement(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value }, options, required, maxLength, minLength, min, max, pattern, validate, }, shallowFieldsStateRef) => {\r\n    const fields = fieldsRef.current;\r\n    const name = ref.name;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = value === '';\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value: requiredValue, message: requiredMessage } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (requiredValue) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox\r\n                    ? ((fields[name].options || [])[0] || {}).ref\r\n                    : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\r\n        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (key, value, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return Object.entries(values)\r\n        .map(([key, value]) => getInnerPath(key, value, isObject(values)))\r\n        .flat(Infinity);\r\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else {\r\n        value = get(fieldValues, fieldName);\r\n        if (isObject(value) || isArray(value)) {\r\n            getPath(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\r\n    const observer = new MutationObserver(() => {\r\n        for (const field of Object.values(fieldsRef.current)) {\r\n            if (field && field.options) {\r\n                for (const option of field.options) {\r\n                    if (option && option.ref && isDetached(option.ref)) {\r\n                        removeFieldEventListenerAndRef(field);\r\n                    }\r\n                }\r\n            }\r\n            else if (field && isDetached(field.ref)) {\r\n                removeFieldEventListenerAndRef(field);\r\n            }\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nconst isWeb = typeof document !== UNDEFINED &&\r\n    !isWindowUndefined &&\r\n    !isUndefined(window.HTMLElement);\r\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const fieldArrayDefaultValuesRef = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const useWatchFieldsRef = useRef({});\r\n    const useWatchRenderFunctionsRef = useRef({});\r\n    const fieldsWithValidationRef = useRef({});\r\n    const validFieldsRef = useRef({});\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const defaultValuesAtRenderRef = useRef({});\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const shallowFieldsStateRef = useRef(shouldUnregister ? {} : Object.assign({}, defaultValues));\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const contextRef = useRef(context);\r\n    const resolverRef = useRef(resolver);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const modeRef = useRef(modeChecker(mode));\r\n    const { isOnSubmit, isOnTouch } = modeRef.current;\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = useState({\r\n        isDirty: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touched: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touched: !isProxyEnabled || isOnTouch,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const formStateRef = useRef(formState);\r\n    const observerRef = useRef();\r\n    const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = useRef(modeChecker(reValidateMode)).current;\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    formStateRef.current = formState;\r\n    const updateFormState = useCallback((state = {}) => !isUnMount.current &&\r\n        setFormState(Object.assign(Object.assign({}, formStateRef.current), state)), []);\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false, state = {}, isValid) => {\r\n        let shouldReRender = shouldRender ||\r\n            isErrorStateChanged({\r\n                errors: formStateRef.current.errors,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state)) {\r\n            updateFormState(Object.assign(Object.assign(Object.assign({}, state), { errors: formStateRef.current.errors }), (resolverRef.current ? { isValid: !!isValid } : {})));\r\n        }\r\n    }, []);\r\n    const setFieldValue = useCallback((name, rawValue) => {\r\n        const { ref, options } = fieldsRef.current[name];\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref) && !isString(value)) {\r\n            ref.files = value;\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = isArray(value)\r\n                    ? !!value.find((data) => data === checkboxRef.value)\r\n                    : value === checkboxRef.value))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, []);\r\n    const isFormDirty = () => !deepEqual(getValues(), isEmptyObject(defaultValuesRef.current)\r\n        ? defaultValuesAtRenderRef.current\r\n        : defaultValuesRef.current) || !isEmptyObject(formStateRef.current.dirtyFields);\r\n    const updateAndGetDirtyState = useCallback((name, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = get(defaultValuesAtRenderRef.current, name) !==\r\n                getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            const state = {\r\n                isDirty: isFormDirty(),\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            if (isChanged && shouldRender) {\r\n                formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\r\n                updateFormState(Object.assign({}, state));\r\n            }\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        if (fieldsRef.current[name]) {\r\n            const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\r\n            shouldRenderBaseOnError(name, error, skipReRender);\r\n            return isUndefined(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (names) => {\r\n        const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = formStateRef.current.isValid;\r\n        if (isArray(names)) {\r\n            const isInputsValid = names\r\n                .map((name) => {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(formStateRef.current.errors, name, error)\r\n                    : unset(formStateRef.current.errors, name);\r\n                return !error;\r\n            })\r\n                .every(Boolean);\r\n            updateFormState({\r\n                isValid: isEmptyObject(errors),\r\n                errors: formStateRef.current.errors,\r\n            });\r\n            return isInputsValid;\r\n        }\r\n        else {\r\n            const error = get(errors, names);\r\n            shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\r\n            return !error;\r\n        }\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const trigger = useCallback(async (name) => {\r\n        const fields = name || Object.keys(fieldsRef.current);\r\n        if (resolverRef.current) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n            updateFormState();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields, readFormStateRef.current.isValid);\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = useCallback((name, value, { shouldDirty, shouldValidate }) => {\r\n        const data = {};\r\n        set(data, name, value);\r\n        for (const fieldName of getPath(name, value)) {\r\n            if (fieldsRef.current[fieldName]) {\r\n                setFieldValue(fieldName, get(data, fieldName));\r\n                shouldDirty && updateAndGetDirtyState(fieldName);\r\n                shouldValidate && trigger(fieldName);\r\n            }\r\n        }\r\n    }, [trigger, setFieldValue, updateAndGetDirtyState]);\r\n    const setInternalValue = useCallback((name, value, config = {}) => {\r\n        if (fieldsRef.current[name]) {\r\n            setFieldValue(name, value);\r\n            config.shouldDirty && updateAndGetDirtyState(name);\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value, config);\r\n            if (fieldArrayNamesRef.current.has(name)) {\r\n                fieldArrayDefaultValuesRef.current[name] = value;\r\n                resetFieldArrayFunctionRef.current[name]({\r\n                    [name]: value,\r\n                });\r\n                if (readFormStateRef.current.isDirty ||\r\n                    readFormStateRef.current.dirtyFields) {\r\n                    set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                    updateFormState({\r\n                        isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), { [name]: value }), defaultValuesRef.current),\r\n                        dirtyFields: formStateRef.current.dirtyFields,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\r\n    }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const renderWatchedInputs = (name, found = true) => {\r\n        if (!isEmptyObject(useWatchFieldsRef.current)) {\r\n            for (const key in useWatchFieldsRef.current) {\r\n                if (!name ||\r\n                    !useWatchFieldsRef.current[key].size ||\r\n                    useWatchFieldsRef.current[key].has(name) ||\r\n                    useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\r\n                    useWatchRenderFunctionsRef.current[key]();\r\n                    found = false;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    };\r\n    function setValue(name, value, config) {\r\n        setInternalValue(name, value, config);\r\n        isFieldWatched(name) && updateFormState();\r\n        renderWatchedInputs(name);\r\n        (config || {}).shouldValidate && trigger(name);\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target.name;\r\n            const field = fieldsRef.current[name];\r\n            let error;\r\n            let isValid;\r\n            if (field) {\r\n                const isBlurEvent = type === EVENTS.BLUR;\r\n                const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent,\r\n                    isReValidateOnChange,\r\n                    isReValidateOnBlur, isTouched: !!get(formStateRef.current.touched, name), isSubmitted: formStateRef.current.isSubmitted }, modeRef.current));\r\n                let state = updateAndGetDirtyState(name, false);\r\n                let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\r\n                if (isBlurEvent &&\r\n                    !get(formStateRef.current.touched, name) &&\r\n                    readFormStateRef.current.touched) {\r\n                    set(formStateRef.current.touched, name, true);\r\n                    state = Object.assign(Object.assign({}, state), { touched: formStateRef.current.touched });\r\n                }\r\n                if (shouldSkipValidation) {\r\n                    renderWatchedInputs(name);\r\n                    return ((!isEmptyObject(state) ||\r\n                        (shouldRender && isEmptyObject(state))) &&\r\n                        updateFormState(state));\r\n                }\r\n                if (resolverRef.current) {\r\n                    const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    error = get(errors, name);\r\n                    isValid = isEmptyObject(errors);\r\n                    if (previousFormIsValid !== isValid) {\r\n                        shouldRender = true;\r\n                    }\r\n                }\r\n                else {\r\n                    error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\r\n                }\r\n                renderWatchedInputs(name);\r\n                shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\r\n            }\r\n        };\r\n    function setFieldArrayDefaultValues(data) {\r\n        if (!shouldUnregister) {\r\n            for (const value of fieldArrayNamesRef.current) {\r\n                if (isKey(value) && !data[value]) {\r\n                    data = Object.assign(Object.assign({}, data), { [value]: [] });\r\n                }\r\n            }\r\n        }\r\n        return data;\r\n    }\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\r\n        }\r\n        if (isArray(payload)) {\r\n            const data = {};\r\n            for (const name of payload) {\r\n                set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            }\r\n            return data;\r\n        }\r\n        return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, shallowFieldsStateRef));\r\n    }\r\n    const validateResolver = useCallback(async (values = {}) => {\r\n        const { errors } = await resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\r\n        const isValid = isEmptyObject(errors);\r\n        formStateRef.current.isValid !== isValid &&\r\n            updateFormState({\r\n                isValid,\r\n            });\r\n    }, [isValidateAllFieldCriteria]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete), [shouldUnregister]);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (field) {\r\n            removeFieldEventListener(field, forceDelete);\r\n            if (shouldUnregister && !filterOutFalsy(field.options || []).length) {\r\n                unset(defaultValuesAtRenderRef.current, field.ref.name);\r\n                unset(validFieldsRef.current, field.ref.name);\r\n                unset(fieldsWithValidationRef.current, field.ref.name);\r\n                unset(formStateRef.current.errors, field.ref.name);\r\n                set(formStateRef.current.dirtyFields, field.ref.name, true);\r\n                updateFormState({\r\n                    errors: formStateRef.current.errors,\r\n                    isDirty: isFormDirty(),\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                });\r\n                resolverRef.current && validateResolver();\r\n            }\r\n        }\r\n    }, [validateResolver, removeFieldEventListener]);\r\n    function clearErrors(name) {\r\n        name &&\r\n            (isArray(name) ? name : [name]).forEach((inputName) => fieldsRef.current[inputName]\r\n                ? isKey(inputName)\r\n                    ? delete formStateRef.current.errors[inputName]\r\n                    : set(formStateRef.current.errors, inputName, undefined)\r\n                : unset(formStateRef.current.errors, inputName));\r\n        updateFormState({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    }\r\n    function setError(name, error) {\r\n        const ref = (fieldsRef.current[name] || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        updateFormState({\r\n            isValid: false,\r\n            errors: formStateRef.current.errors,\r\n        });\r\n        error.shouldFocus && ref && ref.focus && ref.focus();\r\n    }\r\n    const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\r\n        const watchFields = watchId\r\n            ? useWatchFieldsRef.current[watchId]\r\n            : watchFieldsRef.current;\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef, shallowFieldsStateRef, false, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue)\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = isUndefined(watchId);\r\n        return transformToNestObject((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            combinedDefaultValues);\r\n    }, []);\r\n    function watch(fieldNames, defaultValue) {\r\n        return watchInternal(fieldNames, defaultValue);\r\n    }\r\n    function unregister(name) {\r\n        for (const fieldName of isArray(name) ? name : [name]) {\r\n            removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\r\n        }\r\n    }\r\n    function registerFieldRef(ref, validateOptions = {}) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!ref.name) {\r\n                return console.warn(' Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\r\n            }\r\n            if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\r\n                !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\r\n                    .replace(/\\[/g, '\\\\[')\r\n                    .replace(/\\]/g, '\\\\]')).test(ref.name)) {\r\n                return console.warn(' `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const compareRef = (currentRef) => isWeb && (!isHTMLElement(ref) || currentRef === ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let defaultValue;\r\n        if (field &&\r\n            (isRadioOrCheckbox\r\n                ? isArray(field.options) &&\r\n                    filterOutFalsy(field.options).find((option) => {\r\n                        return value === option.ref.value && compareRef(option.ref);\r\n                    })\r\n                : compareRef(field.ref))) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...filterOutFalsy((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign({}, fieldRefAndValidationOptions);\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\r\n        if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\r\n            defaultValue = get(isEmptyUnmountFields\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (!isEmptyObject(validateOptions)) {\r\n            set(fieldsWithValidationRef.current, name, true);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then((error) => {\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    isEmptyObject(error)\r\n                        ? set(validFieldsRef.current, name, true)\r\n                        : unset(validFieldsRef.current, name);\r\n                    if (previousFormIsValid !== isEmptyObject(error)) {\r\n                        updateFormState();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n            set(defaultValuesAtRenderRef.current, name, isEmptyDefaultValue\r\n                ? isObject(fieldValue)\r\n                    ? Object.assign({}, fieldValue) : fieldValue\r\n                : defaultValue);\r\n            !isFieldArray && unset(formStateRef.current.dirtyFields, name);\r\n        }\r\n        if (type) {\r\n            attachEventListeners(isRadioOrCheckbox && field.options\r\n                ? field.options[field.options.length - 1]\r\n                : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, rules) {\r\n        if (!isWindowUndefined) {\r\n            if (isString(refOrValidationOptions)) {\r\n                registerFieldRef({ name: refOrValidationOptions }, rules);\r\n            }\r\n            else if (isObject(refOrValidationOptions) &&\r\n                'name' in refOrValidationOptions) {\r\n                registerFieldRef(refOrValidationOptions, rules);\r\n            }\r\n            else {\r\n                return (ref) => ref && registerFieldRef(ref, refOrValidationOptions);\r\n            }\r\n        }\r\n    }\r\n    const handleSubmit = useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, shallowFieldsStateRef, true));\r\n        if (readFormStateRef.current.isSubmitting) {\r\n            updateFormState({\r\n                isSubmitting: true,\r\n            });\r\n        }\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\r\n                formStateRef.current.errors = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fieldsRef.current)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            unset(validFieldsRef.current, name);\r\n                        }\r\n                        else if (get(fieldsWithValidationRef.current, name)) {\r\n                            unset(formStateRef.current.errors, name);\r\n                            set(validFieldsRef.current, name, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => name in fieldsRef.current)) {\r\n                updateFormState({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\r\n                onInvalid && (await onInvalid(fieldErrors, e));\r\n                shouldFocusError && focusOnErrorField(fieldsRef.current, fieldErrors);\r\n            }\r\n        }\r\n        finally {\r\n            updateFormState({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                errors: formStateRef.current.errors,\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria]);\r\n    const resetRefs = ({ errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        if (!isValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValuesRef.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        updateFormState({\r\n            submitCount: submitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: isDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: isValid ? formStateRef.current.isValid : false,\r\n            dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\r\n            touched: touched ? formStateRef.current.touched : {},\r\n            errors: errors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fieldsRef.current = {};\r\n        defaultValuesRef.current = Object.assign({}, (values || defaultValuesRef.current));\r\n        if (values) {\r\n            renderWatchedInputs('');\r\n        }\r\n        shallowFieldsStateRef.current = shouldUnregister ? {} : Object.assign({}, values) || {};\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        resetRefs(omitResetState);\r\n    };\r\n    observerRef.current =\r\n        observerRef.current || !isWeb\r\n            ? observerRef.current\r\n            : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\r\n    useEffect(() => {\r\n        isUnMount.current = false;\r\n        resolver && readFormStateRef.current.isValid && validateResolver();\r\n        return () => {\r\n            isUnMount.current = true;\r\n            observerRef.current && observerRef.current.disconnect();\r\n            shallowFieldsStateRef.current = {};\r\n            if (process.env.NODE_ENV !== 'production') {\r\n                return;\r\n            }\r\n            fieldsRef.current &&\r\n                Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n        };\r\n    }, [removeFieldEventListenerAndRef]);\r\n    if (!resolver && readFormStateRef.current.isValid) {\r\n        formState.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n    }\r\n    const commonProps = {\r\n        trigger,\r\n        setValue: useCallback(setValue, [setInternalValue, trigger]),\r\n        getValues: useCallback(getValues, []),\r\n        register: useCallback(register, [defaultValuesRef.current]),\r\n        unregister: useCallback(unregister, []),\r\n    };\r\n    const control = Object.assign({ renderWatchedInputs,\r\n        shouldUnregister,\r\n        removeFieldEventListener,\r\n        watchInternal, mode: modeRef.current, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnChange,\r\n        }, fieldsRef,\r\n        isWatchAllRef,\r\n        watchFieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        useWatchFieldsRef,\r\n        useWatchRenderFunctionsRef,\r\n        fieldArrayDefaultValuesRef,\r\n        validFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        readFormStateRef,\r\n        formStateRef,\r\n        defaultValuesRef,\r\n        shallowFieldsStateRef,\r\n        updateFormState, validateResolver: resolver ? validateResolver : undefined }, commonProps);\r\n    return Object.assign({ watch,\r\n        control, formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        if (prop === 'isValid' && isOnSubmit) {\r\n                            console.warn(' `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\r\n                        }\r\n                    }\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState, handleSubmit, reset: useCallback(reset, []), clearErrors: useCallback(clearErrors, []), setError: useCallback(setError, []), errors: formState.errors }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormContext = createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => useContext(FormContext);\r\nconst FormProvider = (_a) => {\r\n    var { children } = _a, props = __rest(_a, [\"children\"]);\r\n    return (createElement(FormContext.Provider, { value: Object.assign({}, props) }, children));\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return filterOutFalsy(data);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(isArray(value) ? value : [value || undefined]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(isArray(value) ? value : [value || undefined]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction mapValueToBoolean(value) {\r\n    if (isObject(value)) {\r\n        const object = {};\r\n        for (const key in value) {\r\n            object[key] = true;\r\n        }\r\n        return [object];\r\n    }\r\n    return [true];\r\n}\r\nvar filterBooleanArray = (value) => (isArray(value) ? value : [value]).map(mapValueToBoolean).flat();\n\nconst appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, value));\r\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\r\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\r\n        }\r\n    }\r\n    const focusIndexRef = useRef(-1);\r\n    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, removeFieldEventListener, formStateRef, formStateRef: { current: { dirtyFields, touched }, }, shallowFieldsStateRef, updateFormState, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, validateResolver, renderWatchedInputs, getValues, shouldUnregister, } = control || methods.control;\r\n    const fieldArrayParentName = getFieldArrayParentName(name);\r\n    const getDefaultValues = () => [\r\n        ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\r\n            ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n            : get(shouldUnregister\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name, [])),\r\n    ];\r\n    const memoizedDefaultValues = useRef(getDefaultValues());\r\n    const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    const allFields = useRef(fields);\r\n    const getCurrentFieldsValues = () => get(getValues() || {}, name, allFields.current).map((item, index) => (Object.assign(Object.assign({}, allFields.current[index]), item)));\r\n    allFields.current = fields;\r\n    fieldArrayNamesRef.current.add(name);\r\n    if (!get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\r\n        set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, get(defaultValuesRef.current, fieldArrayParentName));\r\n    }\r\n    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setFields(fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateResolver) {\r\n            const values = getValues();\r\n            set(values, name, fieldsValues);\r\n            validateResolver(values);\r\n        }\r\n    };\r\n    const getIsDirtyState = (flagOrFields) => (readFormStateRef.current.isDirty ||\r\n        readFormStateRef.current.dirtyFields) &&\r\n        (isUndefined(flagOrFields) ||\r\n            !deepEqual(flagOrFields.map((_a = {}) => {\r\n                var _b = keyName, omitted = _a[_b], rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\r\n                return rest;\r\n            }), get(defaultValuesRef.current, name)));\r\n    const resetFields = () => {\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n            }\r\n        }\r\n    };\r\n    const cleanup = (ref) => !filterOutFalsy(get(ref, name, [])).length && unset(ref, name);\r\n    const batchStateUpdate = (method, args, isDirty = true, shouldSet = true, shouldUpdateValid = false) => {\r\n        if (get(shallowFieldsStateRef.current, name)) {\r\n            const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(shallowFieldsStateRef.current, name, output);\r\n        }\r\n        if (get(fieldArrayDefaultValuesRef.current, name)) {\r\n            const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\r\n            cleanup(fieldArrayDefaultValuesRef.current);\r\n        }\r\n        if (isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touched && get(touched, name)) {\r\n            const output = method(get(touched, name), args.argA, args.argB);\r\n            shouldSet && set(touched, name, output);\r\n            cleanup(touched);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            const output = method(get(dirtyFields, name, []), args.argC, args.argD);\r\n            shouldSet && set(dirtyFields, name, output);\r\n            cleanup(dirtyFields);\r\n        }\r\n        if (shouldUpdateValid &&\r\n            readFormStateRef.current.isValid &&\r\n            !validateResolver) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        updateFormState({\r\n            errors: formStateRef.current.errors,\r\n            dirtyFields,\r\n            isDirty,\r\n            touched,\r\n        });\r\n    };\r\n    const append = (value, shouldFocus = true) => {\r\n        setFieldAndValidState([\r\n            ...allFields.current,\r\n            ...(isArray(value)\r\n                ? appendValueWithKey(value)\r\n                : [appendId(value, keyName)]),\r\n        ]);\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            const dirtyInputs = get(dirtyFields, name, []);\r\n            set(dirtyFields, name, [\r\n                ...(allFields.current.length > dirtyInputs.length\r\n                    ? (fillEmptyArray(allFields.current) || []).map((_, index) => dirtyInputs[index])\r\n                    : dirtyInputs),\r\n                ...filterBooleanArray(value),\r\n            ]);\r\n            updateFormState({\r\n                isDirty: true,\r\n                dirtyFields,\r\n            });\r\n        }\r\n        if (!shouldUnregister) {\r\n            shallowFieldsStateRef.current[name] = [\r\n                ...(shallowFieldsStateRef.current[name] || []),\r\n                value,\r\n            ];\r\n        }\r\n        focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\r\n    };\r\n    const prepend$1 = (value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        setFieldAndValidState(prepend(getCurrentFieldsValues(), isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        resetFields();\r\n        batchStateUpdate(prepend, {\r\n            argA: emptyArray,\r\n            argC: filterBooleanArray(value),\r\n        });\r\n        focusIndexRef.current = shouldFocus ? 0 : -1;\r\n    };\r\n    const remove = (index) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        setFieldAndValidState(removeArrayAt(fieldValues, index));\r\n        resetFields();\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n            argC: index,\r\n        }, getIsDirtyState(removeArrayAt(fieldValues, index)), true, true);\r\n    };\r\n    const insert$1 = (index, value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const fieldValues = getCurrentFieldsValues();\r\n        setFieldAndValidState(insert(fieldValues, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        resetFields();\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: emptyArray,\r\n            argC: index,\r\n            argD: filterBooleanArray(value),\r\n        }, getIsDirtyState(insert(fieldValues, index)));\r\n        focusIndexRef.current = shouldFocus ? index : -1;\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n            argC: indexA,\r\n            argD: indexB,\r\n        }, getIsDirtyState(fieldValues), false);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n            argC: from,\r\n            argD: to,\r\n        }, getIsDirtyState(fieldValues), false);\r\n    };\r\n    const reset = (data) => {\r\n        resetFields();\r\n        !data && unset(fieldArrayDefaultValuesRef.current, name);\r\n        unset(shallowFieldsStateRef.current, name);\r\n        memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\r\n        setFields(mapIds(memoizedDefaultValues.current, keyName));\r\n    };\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!name) {\r\n                console.warn(' useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\r\n        if (defaultValues && fields.length < defaultValues.length) {\r\n            defaultValues.pop();\r\n            set(fieldArrayDefaultValuesRef.current, name, defaultValues);\r\n        }\r\n        if (isWatchAllRef.current) {\r\n            updateFormState();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            let shouldRenderUseWatch = true;\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    updateFormState();\r\n                    shouldRenderUseWatch = false;\r\n                    break;\r\n                }\r\n            }\r\n            shouldRenderUseWatch && renderWatchedInputs(name);\r\n        }\r\n        if (focusIndexRef.current > -1) {\r\n            for (const key in fieldsRef.current) {\r\n                const field = fieldsRef.current[key];\r\n                if (key.startsWith(`${name}[${focusIndexRef.current}]`) &&\r\n                    field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        focusIndexRef.current = -1;\r\n    }, [fields, name]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        if (!getFieldArrayParentName(name)) {\r\n            resetFunctions[name] = reset;\r\n        }\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            fieldArrayNames.delete(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name]),\r\n        remove: useCallback(remove, [name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nfunction useWatch({ control, name, defaultValue, }) {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\r\n        }\r\n    }\r\n    const { useWatchFieldsRef, useWatchRenderFunctionsRef, watchInternal, defaultValuesRef, } = control || methods.control;\r\n    const [value, setValue] = useState(isUndefined(defaultValue)\r\n        ? isString(name)\r\n            ? get(defaultValuesRef.current, name)\r\n            : isArray(name)\r\n                ? name.reduce((previous, inputName) => (Object.assign(Object.assign({}, previous), { [inputName]: get(defaultValuesRef.current, inputName) })), {})\r\n                : defaultValuesRef.current\r\n        : defaultValue);\r\n    const idRef = useRef();\r\n    const defaultValueRef = useRef(defaultValue);\r\n    const updateWatchValue = useCallback(() => {\r\n        const value = watchInternal(name, defaultValueRef.current, idRef.current);\r\n        setValue(isObject(value) ? Object.assign({}, value) : isArray(value) ? [...value] : value);\r\n    }, [setValue, watchInternal, defaultValueRef, name, idRef]);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (name === '') {\r\n                console.warn(' useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\r\n            }\r\n        }\r\n        const id = (idRef.current = generateId());\r\n        const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\r\n        const watchFieldsHook = useWatchFieldsRef.current;\r\n        watchFieldsHook[id] = new Set();\r\n        watchFieldsHookRender[id] = updateWatchValue;\r\n        watchInternal(name, defaultValueRef.current, id);\r\n        return () => {\r\n            delete watchFieldsHook[id];\r\n            delete watchFieldsHookRender[id];\r\n        };\r\n    }, [\r\n        name,\r\n        updateWatchValue,\r\n        useWatchRenderFunctionsRef,\r\n        useWatchFieldsRef,\r\n        watchInternal,\r\n        defaultValueRef,\r\n    ]);\r\n    return (isUndefined(value) ? defaultValue : value);\r\n}\n\nvar getInputValue = (event) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as, render, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\r\n        }\r\n    }\r\n    const { defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: { isReValidateOnBlur, isReValidateOnChange }, formStateRef: { current: { isSubmitted, touched }, }, updateFormState, readFormStateRef, fieldsRef, fieldArrayNamesRef, shallowFieldsStateRef, } = control || methods.control;\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\r\n        ? get(shallowFieldsStateRef.current, name)\r\n        : isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue;\r\n    const [value, setInputStateValue] = useState(getInitialValue());\r\n    const valueRef = useRef(value);\r\n    const onFocusRef = useRef(onFocus);\r\n    const shouldValidate = (isBlurEvent) => !skipValidation(Object.assign({ isBlurEvent,\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted, isTouched: !!get(touched, name) }, mode));\r\n    const commonTask = ([event]) => {\r\n        const data = getInputValue(event);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    };\r\n    const registerField = useCallback(() => {\r\n        if (process.env.NODE_ENV !== 'production' && !name) {\r\n            return console.warn(' Field is missing `name` prop. https://react-hook-form.com/api#Controller');\r\n        }\r\n        if (fieldsRef.current[name]) {\r\n            fieldsRef.current[name] = Object.assign({ ref: fieldsRef.current[name].ref }, rules);\r\n        }\r\n        else {\r\n            register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\r\n                set(data) {\r\n                    setInputStateValue(data);\r\n                    valueRef.current = data;\r\n                },\r\n                get() {\r\n                    return valueRef.current;\r\n                },\r\n            }), rules);\r\n            if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\r\n                setInputStateValue(getInitialValue());\r\n            }\r\n        }\r\n    }, [rules, name, register]);\r\n    useEffect(() => () => {\r\n        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\r\n    }, [unregister, name, fieldArrayNamesRef]);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (isUndefined(value)) {\r\n                console.warn(` ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\r\n            }\r\n            if ((!as && !render) || (as && render)) {\r\n                console.warn(` ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`);\r\n            }\r\n            if (!isNotFieldArray && isUndefined(defaultValue)) {\r\n                console.warn(' Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\r\n            }\r\n        }\r\n        registerField();\r\n    }, [registerField]);\r\n    useEffect(() => {\r\n        if (!fieldsRef.current[name]) {\r\n            registerField();\r\n            if (isNotFieldArray) {\r\n                setInputStateValue(getInitialValue());\r\n            }\r\n        }\r\n    });\r\n    const onBlur = () => {\r\n        if (readFormStateRef.current.touched && !get(touched, name)) {\r\n            set(touched, name, true);\r\n            updateFormState({\r\n                touched,\r\n            });\r\n        }\r\n        if (shouldValidate(true)) {\r\n            trigger(name);\r\n        }\r\n    };\r\n    const onChange = (...event) => setValue(name, commonTask(event), {\r\n        shouldValidate: shouldValidate(),\r\n        shouldDirty: true,\r\n    });\r\n    const props = Object.assign(Object.assign({}, rest), { onChange,\r\n        onBlur,\r\n        name,\r\n        value });\r\n    return as\r\n        ? isValidElement(as)\r\n            ? cloneElement(as, props)\r\n            : createElement(as, props)\r\n        : render\r\n            ? render({\r\n                onChange,\r\n                onBlur,\r\n                value,\r\n                name,\r\n            })\r\n            : null;\r\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };\n//# sourceMappingURL=index.esm.js.map\n"],"sourceRoot":""}